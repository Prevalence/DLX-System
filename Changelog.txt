1.去掉了添加在LW和LB指令处理函数中的Sleep函数
2.禁止了每条指令执行完毕之后对界面上指令条数的刷新.目前暂时使用了一个简单的方法:仅在CPUInfo.RunProgram函数的最后,即跳出执行指令的while循环后刷新指令数.执行指令过程中仅显示"Executing instructions..."
另外,对于Run和Debug方式运行的指令,指令数的位置现在改为显示指令执行速度.指令条数太长,会超出空间能显示的范围.
3.取消了DLX控制台下方的显示器键盘状态显示.
每一次状态变化都用一个独立的线程来控制,本身代价已经过大了.当输入或输出文本时又会大量调用System.Windows.Threading.Thread.Abort函数,这个函数用抛出异常的方式来终止线程.在profiling中显示这样终止一个线程的时间开销是启动一个线程的20余倍.而模拟器的指令执行必须等待这个缓慢的过程.
目前暂时直接将这一功能取消.
4.修改了ConsoleCanvas中AppendChar函数的实现,现在令界面线程刷新界面的语句改用了Dispatcher.BeginInvoke函数,不必等待委托的调用完成即可返回.
这一修改将显示设备的数据缓冲和屏幕显示分开处理.数据依然会立刻写入显示设备的数据缓冲中,但屏幕显示是异步更新的.
5.修正了DlxConsole的实现,现在能够正确输入[,],{和}这四个字符.
6.增强了界面内存缓冲树(MemoryTree类)的性能,修改了提供给VM的回调函数(cpu_ValueChangeEvent)的实现机制.
现在仅对需要显示的内存地址的节点进行建立和更新.
这一更新解决了载入大型程序时程序长时间无响应问题.
7.将VM处理指令的函数从基于String类型进行操作改为基于int型
8.改变了VM中查找指令处理函数的机制.
现在不再每处理一条指令都调用基于String的反射方法,而是在Computer类初始化时一次性将所有指令处理函数存入一个SortedDictionary数据结构中.实际执行指令时根据指令码(int型)在集合中查找.
9.修改了模拟器初始化(Reset Memory)处理函数的实现.增加了对DSR所指向的内存地址的赋值.
[备注]:本来希望将模拟器的时钟中断改成基于时间的,但是由于精确的定时方法性能开销较大,不能直接放在执行指令时执行,需要额外的设计(如使用单独的计时线程).性能开销小的定时方法只能产生最高50Hz的中断,可能不能满足一些应用的需要.现在的定时方法是基于指令执行数,但是据观察最快的指令的执行时间大概为最慢指令执行时间的60%-80%,因此这种定时方法并不可靠.